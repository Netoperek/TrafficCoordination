\chapter{Istniejące rozwiązania w zakresie planowania ruchu i koordynacji ruchu na skrzyżowaniach} \label{chap:state-of-the-art}

\section{Planowanie ruchu na skrzyżowaniach}

\textbf{Cel - lista wymagań i cech mojego rozwiązania - tego nie będzie w treści}
\newline
- Zastosowanie algorytmu A* do zaplanowania ruchu na skrzyżowaniach
\newline
- Brak świateł powinno przyspieszyć ruch na szkyżowaniach - auta nie czekają na świetle pomarańczowym
\newline
- Rozwiązanie uwzględnia unikanie kolizji
\newline
- A* powinien szybciej zaplanować drogę niż np. Dijkstra
\newline
- W rozwiązaniu zapewnione jest bezpieczeństwo - nie dochodzi do kolizji
\newline
- Rozwiązanie koordynuje ruch globalnie
\newline
\newline
\newline
\newline
\indent
  Planowanie ruchu zawsze wiąże się z rozmiarem problemu. Dla koordynacji ruchu na skrzyżowaniach rozmiarem problemu jest rozmiar dróg, ich liczba oraz liczba przecięć między nimi, a także parametry i liczba pojazdów. Z planowaniem ruchu wiąże się trudność jaką jest szybkość zmian w środowisku. W przypadku nie zastosowania się pojazdu do planu, algorytm musi natychmiast wyliczyć poprawiony plan. Z tego względu algorytm nie powinien zajmować dużo czasu. Algorytmy heurystyczne są najczejściej stosowane w często zmieniających się środowiskach.
\newline
\indent
  Często stosowanym algorytmem do znajdowania najkrótszej ścieżki w grafie jest algorytm Dijkstry. O rzędzie złożoności algorytmu decyduje implementacja kolejki. W przypadku implementacji kolejki poprzez kopiec złożoność algortmu to:
\newline
\newline
\begin{math}
O(E + V\log V)
\end{math}
\newline
\newline
gdzie \begin{math}E\end{math} to liczba krawędzi grafu, a \begin{math}V\end{math} liczba wierzchołków grafu.
\indent
\newline
\newline
\indent
  Algorytmem heurystycznym stosowanym do szukania najkrótszej ścieżki jest Algorytm A*. Złożoność czasowa algorytmu jest zależna od zastosowanej funkcji heurystyki. Jeśli funkcja heurystyki spełnia następujący warunek:
\newline
\newline
\begin{math}
|h(x)-h^{*}(x)|=O(\log h^{*}(x))
\end{math}
\newline
\newline
gdzie \begin{math}h*\end{math} jest optymalną heurystyką - liczba przeszukanych węzłów rośnie wielomianowo w stosunku do długości rozwiązania.
\newline
\newline
\indent
W artykule \cite{wojnicki2015robust} autorzy przedstawili algorytm A* w celu planowania wielowymiarowego. W celu przybliżenia złożoności jako przykładowe środowisko podana została dwuwymiarowa, dyskretna przestrzeń kwadratowa o boku 7. Pojazdy mogą zajmować wówczas 49 pozycji oznaczonych współrzednymi \begin{math}(x, y)\end{math}. Dla jednego pojazdu, możliwość zajmowanych pozycji wynosi \begin{math}(7 * 7) = 49 \end{math}. Dla dwóch pojazdów jest to już \begin{math}(7 * 7) * (7 * 7 - 1) = 2352 \end{math}. Aktualny stan jest wówczas opisywany jako \begin{math}(x1, y1, x2, y2)\end{math}. Złożoność rośnie wraz z przetrzymywaniem kolejnych informacji na temat pojazdów, czyli  na przykład prędkośći czy przyspieszenia.
\newline
\indent
Autorzy artykułu \cite{leena2014survey} zwrócili uwagę na podział planowania na globalne i lokalne. W podejśćiu globalnym dla algorytmu musi być znane całe środowisko co wiąże się z dużym obciążeniem pamięciowym - algorytm przechowuje informacje na temat stanów wszystkich pojazdów na skrzyżowaniach. W podejśćiu lokalnym środowisko dla pojedyńczego pojazdu nie jest znane, algorytm poznaje je w czasie rzeczywistym. W przedstawionym rozwiązaniu zastosowane jest podejście globalne.

\section{Planowanie ruchu przy użyciu świateł drogowych}

\indent
Najczęściej stosowanym systemem do koordynacji ruchu na skrzyżowaniach są światła drogowe. Powodują one opóźnienia wiążące się z oczekiwaniem przy świetle pomarańczowym, które jednocześnie zapewnia bezpieczeństwo. Powstało wiele optymalizacji świateł drogowych w celu przyspieszenia ruchu na skrzyżowaniach.
\newline
\indent
W artykule \cite{brockfeld2001optimizing} autorzy opisują następujące optymalizacje sygnalizacji świetlnej: \textit{Synchronized Traffic Lights, Green Wave, Random Offset}. Synchroniczne światła drogowe oparte są o obliczane cykle oraz o klastry samochodow poruszających się po skrzyżowaniach. Klaster samochodów rusza, gdy pojawi się światło zielone. Pierwszy samochód rusza z największym przyspieszeniem, aż dojedzie do następnego skrzyżowania. Wówczas natychmiast włącza się światło czerwone i reszta samochodów w klastrze dojeżdża do skrzyżowania. Cykle są obliczane w sposób, aby opóźnienia były najmniejsze. Zgodnie ze zdaniem autorów, jedną z wad jest fakt, że rozwiązanie działa najlepiej dla nierealistycznych cykli. W celu usprawnienia autorzy zaproponowali strategię zielonej fali. Głównym celem tego podejście jest to, aby duże klastry samochodów były w ruchu. W artykule, strategia zielonej fali daje lepsze efekty niż startegia synchronicznych świateł. Ostatnią przedstawioną strategią jest losowa zmiana świateł przed skrzyżowaniami. W przeciwieństwie do poprzednich strategii - światła na skrzyżowanach nie przełączją się jednocześnie. Użycie tej strategii powoduje powstawanie dużych klastrów samochodów na niektórych drogach i szybki przepływ na innych. Globalnie strategia zielonej falii przynosiła najlepsze efekty. Przedstawione rozwiązania muszą jednak stosować światło pomarańczowe w celu utrzymania bezpieczeństwa co powoduje opóźnienia na każdym skrzyżowaniu.
\newline
\indent
Autorzy artykułu \cite{athmaraman2005adaptive} opisują koordynację ruchu przy użyciu algorytmu 'REAL TIME QUEUE LENGTH ESTIMATION: THE APTTC ALGORITHM'. Koordynacja ta działa przy użyciu tablicy sensorów fotoelektrycznych rozmieszczonych w topologii. Algorytm w zależności od danych i estymacji kolejek odpowowiednio steruje sygnalizacją świetlną w celu uniknięcia opóźnień. Algorytm został uruchomiony w mieście Chennai w Indiach, gdzie wyestymowane zostały długości kolejek aut na drogach poprzez zamontowane sensory na każdy dzień tygodnia. Rozwiązanie jest jednak zaprojektowane do działania na jednym skrzyżowaniu oraz nie eliminuje opóźnień spowodowachnych światłem pomarańczowym. Co więcej, w rozwiązaniu konieczne jest montowanie sensorów na drogach.
\newline
\indent
W artykule \cite{de1998optimal} opisane zostało kierowanie ruchem drogowym na jednym skrzyżowaniu poprzez optymalizację kolejek. W rozwiązaniu brane pod uwage są takie dane jak: średni czas oczekiwania, średnia długość kolejki, najgorszy czas oczekiwania. Istnieje także możliwość przekazania parametrów odpowiadających za maksymalny czas trwania światła czerwonego oraz zielonego. Wynikiem rozwiązania jest schemat zmiany świateł, który liczony jest za pomocą funkcji obiektowych na podstawie długości kolejek. W rozwiązaniu pominięty został element bezpieczeństwa jakim jest światło pomarańczowe. Rozwiązanie zostało pokazane także na jednym skrzyżowaniu, a nie na całej sieci skrzyżowań.
\newline
\indent
  Autorzy artykulu \cite{lammer2008self} przedstawili system kontroli świateł i przepływu pojazdów na sieciach drogowych. Rozwiązanie stosowane jest dla całych sieci skrzyżowań. Autorzy opierają się o krótkie prognozu ruchu i na ich podstawie liczą długość trwania światła zielonego. Klasyczne rozwiązania działają na wcześniej obliczonych danych oraz działają we wcześniej określonych miejscach największego ruchu. Takie rozwiązania powodują, że zielona fala trwa dużej niż powinna. W rozwiązaniu zastosowana jest także strategia stabilizacji, która zapewnia fakt, iż długość kolejek nie będzie zbyt długa. Zapewnione jest to przez odpowiednią długość trwania światła zielonego. W rozwiązaniu, na każdym ze skrzyżowań, samochody będą tracic czas na świetle pomarańczowym, które w rozwiązaniu jest konieczne, aby było ono bezpieczne. Ruch jest także optymalizowany dla sytuacji "średnich", które tak na prawdę nigdy nie występują. Wynikiem tego zjawiska jest fakt, że optymalizacja nie jest nigdy stosowana dla prawdziwej, aktualnej sytuacji.
\newline
\indent
W artykule \cite{ferreira2010self} przedstawiony został system zarządzania światłami za pomocą komunikacji pojazdów między sobą. Działanie systemu opiera się o sensory zamontowany przy skrzyżowaniach oraz urządzenia DSRC zamontowane w każdym z aut. Pojazdy komunikują się ze sobą za pomoca sieci bezprzewodowej, posiadają te same wersje map oraz posiadają GPS z dokładnością do pasa na którym się znajdują. W zależności od zebranych danych system odpowiednio przełącza światła w celu uniknięcia opóźnień. Przedstawione rozwiązanie jest kosztowne oraz pominięta jest kwestia bezpieczeństwa, która w innych rozwiązaniach zapewniona jest poprzez oczekiwaniu na świetle pomarańczowym.
    
\section{Planowanie ruchu bez sygnalizacji świetlnej}

W celu uniknięcia użycia świateł drogowych istnieją także rozwiązania z wykorzystaniem algorytmów znajdujących najkrótszą ścieżkę. W artykule \cite{shaikh2013agv} autorzy wykorzystali algorytm Dijkstry do zarządzania ruchem przy użyciu automatycznie prowadzonych pojazdów. Autorzy przedstawili zarządzanie ruchem pojazdów w magazynie chcąc ogarniczyć czas transportu. Algorytm Dijkstry wskazuje najkrótszą ścieżkę od jednego pojazdu do następnego. W przypadku, gdy na ścieżce znajdzie się przeszkoda - algorytm wylicza ścieżkę od nowa. Zastosowanie algorytmu Dijkstry do koordynacji ruchu na skrzyżowaniach jest zbyt złożone. Ponadto, unikanie kolizji jest wykonane poprzez ponowne wyliczanie najkrótszej ścieżki, zamiast unikania ich na bieżąco.
\newline
\indent
Autorzy artykułu \cite{huang2013improved} przedstawiają ulepszoną wersję algorytmu Dijkstry w celu znalezienia najkrótszej ścieżki. Do algorytmu Dijkstry wprowadzona została funkcja dzięki której ignorowane są nieistotne wierzchołki w grafie. Dzięki tej modyfikacji algorytm jest jest ~43\%-76\% szybszy. Rozwiązanie jest nadal zbyt złożone by zastosować go do koordynacji ruchu na skrzyżowaniach. W rozwiązanie nie ma także uwzględnionego unikania kolizji.
\newline
\indent
W artykule \cite{ando2003autonomous} przedstawione zostało planowanie ruchu przy użyciu automatycznie prowadzonych pojazdów wraz z unikaniem kolizji. W rozwiązaniu każdy robot indywidualnie liczy najkrótszą dla siebie ścieżkę. Następnie dane tras są wymieniane pomiędzy robotami w celu ustalenia finalnego rozwiązania. Szukanie ścieżki jest wykonywane przy użyciu algorytmu Dijkstry. W celu unikania kolizji dla każdego pojazdu liczona jest funkcja kary. Waga kary jest zwiększa tak długo, aż zostanie znaleziona bezkolizyjna ścieżka. Złożoność rozwiązania jest zbyt duża by zastosować je dla skrzyżowań. Wymienianie danych pomiędzy pojazdami oraz podany w rozwiązaniu sposób rozwiązywania kolizji nie znajduje zastosowania w koordynowaniu ruch na skrzyżowaniach.
\newline
\indent
W patencie \cite{gazis1997optimal} autorzy przedstawili centralnie zaplanowany, generalny system przydzielający trasy w celu utrzymania optymalnego ruchu. System zawiera dużą ilość komputerów zamontowanych w pojazdach w celu komunikacji między nimi poprzez sieć bezprzewodową. Do znajdownia najkrótszej ścieżki autorzy wykorzystali algorytm Dijkstry. Ścieżki liczone są przy użyciu daynch dostarczanych przez komputery zamontowane w pojazdach. Celem patentu jest znalezienie drogi do celu w najkrótszym czasie poprzez omijanie zakorkowanych dróg. Nie jest to dokładne zaplanowanie poruszania się pojazdu wraz z unikaniem kolizji.
\newline
\indent
Autorzy patentu \cite{broxmeyer1994vehicle} opisali system do kontroli ruchu i unikania kolizji na autostradach. Pod uwage wzięte zostały zmiany pasów, unikanie kolizji oraz kontrolowanie trasy pojazdu. Unikanie kolizji zostało zapewnione poprzez komunikacje przez transmitery radiowe oraz radioodbiorniki zamontowane w każdym z pojazdów. Rozwiązanie znajduje zastosowanie na autostradach, unikanie kolizji ma miejsce na równoległych pasach. Tego podejścia nie da się zastosować jeżeli chodzi o koordynacje ruchu na skrzyżowaniach.
\newline
\indent
W artykule \cite{kanoh2007dynamic} przedstawiony został system dynamicznego planowania ruchu do nawigacji samochodów przy użyciu 'virus genetic algorithms'. Autorzy zaproponowali algorytm genetyczny, który jest bardziej wydajny od algorytmu A* czy algorytmu Dijkstry. W rozwiązaniu zastosowana jest strategia infekcji wirusowej, dzięki czemu omijane są korki na drogach. Rozwiązanie jest zaprojektowane do wskazania najlepszej trasy, nie jest to dokładne zaplanowanie ruchu samochodów wraz z wymijaniem kolizji.

\section{Użycie algorytmu A* do planowania ruchu}

\indent
Algorytm A* jest często stosowany do szukania najkrótszej ścieżki oraz planowania ruchu. W artykule \cite{dechter1985generalized} omówiona została optymalność tego algorytmu oraz funkcja heurystyki. A* jest algorytmem heurystycznym, który znajduje najkrótszą ścieżkę w grafie ważonym z dowolnego podanego wierzchołka do wierzchołka celu. Wierzchołkiem celu jest wierzchołek spełniający zadane warunki wygranej. W artykule przedstawione zostały poprzednie próby udowodnienia optymalności algorytmu. Autorzy przeprowadzili także własny dowód na optymalność algorytmu A*. Dowód polega na fakcie, iż kiedy funkcja heurystyki nigdy nie przeszacowuje wtedy algorytm A* jest optymalny. Dla grafu, algorytm A* od zadanego wierzchołka startowego tworzy ścieżkę, wybierając niezbadany sąsiedni wierzchołek. Wybiera go w sposób aby minimalizować funkcję:
\newline
\newline
\begin{math} f(x) = g(x) + h(x)\end{math}
\newline
\newline
gdzie:
\newline
\newline
\begin{math} g(x) \end{math} to suma wag krawędzi od wierzchołka startowego do wierzchołka x, a
\begin{math} h(x) \end{math} to przewidywana przez funkcję heurystyki suma wag z wierzchołka x do wierzchołka docelowego.
\newline
\indent
W artykule \cite{delling2009engineering} autorzy przeprowadzili porównanie algorytmów do planowania drogi. Na początku omówiony został algorytm Dijkstry, aby później pokazać algorytmy od niego szybsze. Następnie, autorzy przedstawiają kolejki priorytetowe jako implementację algorytmu Dijkstry, które są w stanie poprawic jego złozoność z \begin{math} O(n^2) \end{math} do \begin{math} O(nlogn) \end{math}. Używanie kolejek priorytetowych nie sprawdza sie jednach na bardzo dużych zbiorach danych. Następną zaproponowaną modyfikacją algorytmu Dijkstry jest wyszukiwanie dwukierunkowe. Algorytm równolegle uruchamia algorytm Dijkstry, w stronę celu oraz w stronę startu. Kiedy wierzchołek jest odwiedzony z dwóch strony, ścieżka może być znaleziona. Kolejno opisany został Algorytm A* korzystający z funkcji heurystyki opartej o odległość Euklidesową. Według autorów znajdywanie najkrótszej ścieżko jest niewiele przyspieszone. Mimo to czas wykonania algorytmu A* jest krótszy od czasu wykonania algorytmu Dijkstry.
\newline
\indent
Wykorzystanie modyfikacji algorytmu A* wraz z algorytmem Wavefront zostało przedstawione w artykule \cite{wojnicki2015robust}. Autorzy przedstawili wersję algorytmu A*, która operuje na stanach. Autorzy pokazali przykład na dwuwymiarowej, dyskretnej przestrzeni kwadratowej o boku 7. Stanem początkowym jest rozłożenie czterech obiektów na rogach zadanej przestrzeni. Stanem końcowym natomiast, jest znalezienie się tych czterech obiektów po przeciwnych stronach przekątnych. Algortym Wavefront został zastosowany w celu otrzymania planów wielowariantowych dla obiektów. Zastosowanie algorytmu A* operującego na stanach wraz z prędkościami pojazdów wnosi duże narzuty obliczeniowe. Przeprowadzenie koordynacji ruchu dla dużych sieci skrzyżowań używając algorytmu A* wraz z Wavefront jest zbyt złożone.
\newline
\indent
W artykul \cite{elhalawany2013modified} autorzy zaproponowali modyfikację algorytmu A*, która skupia sie na bezpieczeństwie w problemie nawigacji robotów. Modyfikacja polega na wzięciu pod uwagę rozmiaru robota oraz unikanie ostrych skrętów jeżeli chodzi o bezpieczeństwo. Do algorytmu A* przekazywany jest stan początkowy oraz cel jaki robot ma osiągnąc. Rozwiązanie przedstawione jest dla pojedyńczego pojazdu, który ma za zadanie znaleźć najprosztą i bezpieczną ścieżkę wraz z unikaniem statycznych kolizji. Tego podejścia nie da się zastosować dla wielu pojazdów poruszających się po sieci skrzyżowań.

\section{Modyfikacje A*}

\indent
Autorzy artykułu \cite{munteanmobile} opisali modyfikację algorytmu A* do planowania ruchu. Rozwiązanie zostało zaprezentowanie dla robotów mobilnych. Autorzy stwierdzają fakt, że algorytm A* dla dużych danych potrzebuje dużo pamięci żeby śledzić dane, które są związane z aktualnym wierzchołkiem. Wspomniana została także modyfikacja algorytmu A*, która polega na równoczesnym przeszukiwaniu grafu w dwóch kierunkach. Kolejną modyfikacją jest IDA*, która nie używa pamięci do przechowywania wcześniej odwiedzonych wierzchołków. Minusem tej modyfikacji jest fakt, iż IDA* odwiedza niektóre wierzchołki wiele razy. Na końcu, autorzy zaproponowali swoją modyfikację - Fast A*. W modyfikacje zamiast list, użyte zostały drzewa binarne w celu przechowywania danych. W wyniku pracy zmodyfikowany algorytm Fast A* dawał lepsze wyniki od wersji klasycznej. Przedstawione modyfikacje są oparte o działanie na grafie, polegające na znalezieniu najkrótszej ściezki z punktu startowego do punktu końcowego. Modyfikacje nie są wstanie wskazać najkrótszej ścieżki dla stanu początkowego i końcowego, którym może być na przykład położenie wszystkich samochodów na skrzyżowaniach.
\newline
\indent
W artykule \cite{oleiwi2014modified} autorzy zaproponowali genetyczny algorytm oparty na zmodyfikowanym algorytmie A* w celu optymalizacji znajdowania ścieżek dla wielu obiektów. Modyfikacja algorytmu A* polega na znalezieniu ścieżki suboptymalnej poprzez dodanie do algorytmu funkcji prawdopodobieństwa. Uniknięto więc szukania najkrótszej ścieżki, aby zwiększyc optymalność algorytmu. To rozwiązanie następnie jest przekazywane to algorytmu genetycznego. W rozwiązaniu uwzględnione zostało także unikanie kolizji. Autorzy opisali podejście optymalizacji szukania najkrótszej ścieżki dla pojedyńczego pojazdu z unikaniem kolizji ze statycznymi elemntami. Tego rozwiązania nie da się zastosować w sieci skrzyżowań, na której znajduje się wiele aut.
